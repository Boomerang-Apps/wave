"""
WAVE v2 Developer Node

Uses Claude to generate code based on requirements and plan.
This is the primary coding agent in the WAVE workflow.
"""

import os
from datetime import datetime
from typing import Callable, Optional

# Import state types
import sys
_src_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if _src_dir not in sys.path:
    sys.path.insert(0, _src_dir)

try:
    from src.graph import WAVEState, Phase, Gate
except ImportError:
    from graph import WAVEState, Phase, Gate

# Try to import MultiLLMClient
try:
    from src.multi_llm import MultiLLMClient, LLMProvider
    MULTI_LLM_AVAILABLE = True
except ImportError:
    try:
        from multi_llm import MultiLLMClient, LLMProvider
        MULTI_LLM_AVAILABLE = True
    except ImportError:
        MULTI_LLM_AVAILABLE = False
        LLMProvider = None


# ═══════════════════════════════════════════════════════════════════════════════
# PROMPTS
# ═══════════════════════════════════════════════════════════════════════════════

DEVELOPER_SYSTEM_PROMPT = """You are an expert software developer working on the WAVE autonomous coding system.

Your role is to:
1. Analyze requirements and implementation plans
2. Write clean, well-tested code
3. Follow best practices and coding standards
4. Include appropriate error handling
5. Write tests alongside implementation

Guidelines:
- Write production-quality code
- Include docstrings and type hints
- Follow the existing codebase patterns
- Implement only what is required (no over-engineering)
- Always include unit tests

Output Format:
Return your code in markdown code blocks with appropriate language tags.
Separate implementation from tests with clear headers.
"""

DEVELOPER_PROMPT_TEMPLATE = """## Task
Implement the following requirement:

{requirements}

## Plan
{plan}

## Project Context
- Project: {project_path}
- Story ID: {story_id}

## Instructions
1. Write the implementation code
2. Write unit tests
3. Explain any design decisions

Please provide the complete implementation:
"""


# ═══════════════════════════════════════════════════════════════════════════════
# DEVELOPER NODE
# ═══════════════════════════════════════════════════════════════════════════════

def developer_node(state: WAVEState) -> dict:
    """
    Developer node that generates code using Claude.

    Args:
        state: Current WAVE workflow state

    Returns:
        dict with updates:
        - code: Generated code
        - phase: Updated to QA
        - gate: Updated to DEV_COMPLETE
        - updated_at: Timestamp
    """
    requirements = state.get("requirements", "")
    plan = state.get("plan", "No plan provided")
    project_path = state.get("project_path", "")
    story_id = state.get("story_id", "")

    # Check if we have requirements
    if not requirements:
        return {
            "error": "No requirements provided for development",
            "error_count": state.get("error_count", 0) + 1,
            "phase": Phase.FAILED.value
        }

    # Build the prompt
    prompt = DEVELOPER_PROMPT_TEMPLATE.format(
        requirements=requirements,
        plan=plan,
        project_path=project_path,
        story_id=story_id
    )

    # Try to use Claude via MultiLLMClient
    if MULTI_LLM_AVAILABLE and os.getenv("ANTHROPIC_API_KEY"):
        try:
            client = MultiLLMClient()
            response = client.query(
                prompt,
                LLMProvider.CLAUDE,
                system_prompt=DEVELOPER_SYSTEM_PROMPT
            )
            code = response
        except Exception as e:
            # Fallback to simulated response
            code = _generate_simulated_code(requirements)
    else:
        # No API key or client - generate simulated response
        code = _generate_simulated_code(requirements)

    # Update budget tracking
    budget = state.get("budget", {})
    tokens_used = budget.get("tokens_used", 0) + len(prompt.split()) + len(code.split())

    return {
        "code": code,
        "phase": Phase.QA.value,
        "gate": Gate.DEV_COMPLETE.value,
        "updated_at": datetime.now().isoformat(),
        "budget": {
            **budget,
            "tokens_used": tokens_used
        }
    }


def _generate_simulated_code(requirements: str) -> str:
    """Generate simulated code when Claude is not available."""
    return f'''"""
Auto-generated code for: {requirements[:50]}...
Generated by WAVE Developer Node (simulated mode)
"""

def main():
    """Main implementation."""
    # TODO: Implement based on requirements
    pass


def test_main():
    """Test the main implementation."""
    # TODO: Add tests
    assert True, "Placeholder test"


if __name__ == "__main__":
    main()
'''


# ═══════════════════════════════════════════════════════════════════════════════
# FACTORY FUNCTION
# ═══════════════════════════════════════════════════════════════════════════════

def create_developer_node(
    client: Optional["MultiLLMClient"] = None,
    system_prompt: str = DEVELOPER_SYSTEM_PROMPT
) -> Callable[[WAVEState], dict]:
    """
    Create a developer node with custom configuration.

    Args:
        client: Optional MultiLLMClient instance
        system_prompt: Custom system prompt

    Returns:
        Configured developer node function
    """
    def configured_developer_node(state: WAVEState) -> dict:
        requirements = state.get("requirements", "")
        plan = state.get("plan", "No plan provided")

        if not requirements:
            return {
                "error": "No requirements provided",
                "error_count": state.get("error_count", 0) + 1,
                "phase": Phase.FAILED.value
            }

        prompt = DEVELOPER_PROMPT_TEMPLATE.format(
            requirements=requirements,
            plan=plan,
            project_path=state.get("project_path", ""),
            story_id=state.get("story_id", "")
        )

        if client and os.getenv("ANTHROPIC_API_KEY"):
            try:
                response = client.query(
                    prompt,
                    LLMProvider.CLAUDE,
                    system_prompt=system_prompt
                )
                code = response
            except Exception:
                code = _generate_simulated_code(requirements)
        else:
            code = _generate_simulated_code(requirements)

        return {
            "code": code,
            "phase": Phase.QA.value,
            "gate": Gate.DEV_COMPLETE.value,
            "updated_at": datetime.now().isoformat()
        }

    return configured_developer_node


# ═══════════════════════════════════════════════════════════════════════════════
# EXPORTS
# ═══════════════════════════════════════════════════════════════════════════════

__all__ = [
    "developer_node",
    "create_developer_node",
    "DEVELOPER_SYSTEM_PROMPT",
    "DEVELOPER_PROMPT_TEMPLATE",
]
