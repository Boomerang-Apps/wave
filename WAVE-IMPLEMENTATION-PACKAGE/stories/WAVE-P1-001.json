{
  "$schema": "../../planning/schemas/story-schema-v4.2.json",
  "schema_version": "4.2",
  "story_id": "WAVE-P1-001",
  "title": "Implement PostgreSQL State Schema with Prisma",
  "type": "infrastructure",
  "domain": "backend",
  "agent": "be-dev",
  "wave_number": 1,
  "priority": "P0",
  "story_points": 5,
  "status": "pending",
  "description": "Create PostgreSQL database schema for WAVE state persistence including sessions, checkpoints, and story executions. Use Prisma for migrations and type-safe queries. This enables crash recovery and audit trails.",

  "objective": {
    "as_a": "WAVE Orchestrator",
    "i_want": "persistent state storage in PostgreSQL",
    "so_that": "execution state survives crashes and can be audited"
  },

  "acceptance_criteria": [
    {
      "id": "AC-01",
      "description": "Prisma schema defines all required tables with proper relationships",
      "ears_format": "WHEN prisma generate runs THEN TypeScript types are created for all models",
      "test_approach": "Run prisma generate and verify types in node_modules/.prisma/client",
      "status": "pending"
    },
    {
      "id": "AC-02",
      "description": "Migrations apply without errors on clean database",
      "ears_format": "WHEN prisma migrate deploy runs THEN all tables exist in database",
      "test_approach": "Run migration and query information_schema.tables",
      "status": "pending"
    },
    {
      "id": "AC-03",
      "description": "Session CRUD operations work correctly",
      "ears_format": "WHEN session created THEN it can be read back with correct data",
      "test_approach": "Integration test: create → read → verify fields match",
      "status": "pending"
    },
    {
      "id": "AC-04",
      "description": "Checkpoint CRUD operations work correctly",
      "ears_format": "WHEN checkpoint created for session THEN it appears in session.checkpoints",
      "test_approach": "Integration test: create session → add checkpoint → query",
      "status": "pending"
    },
    {
      "id": "AC-05",
      "description": "Indexes created for common queries",
      "ears_format": "WHEN database inspected THEN indexes exist on session_id, project_id",
      "test_approach": "Query pg_indexes for expected indexes",
      "status": "pending"
    }
  ],

  "files": {
    "create": [
      "orchestrator/prisma/schema.prisma",
      "orchestrator/prisma/migrations/001_initial/migration.sql",
      "orchestrator/src/db/client.ts",
      "orchestrator/src/db/sessions.ts",
      "orchestrator/src/db/checkpoints.ts",
      "orchestrator/src/db/story-executions.ts",
      "orchestrator/src/db/types.ts",
      "orchestrator/src/db/__tests__/sessions.test.ts",
      "orchestrator/src/db/__tests__/checkpoints.test.ts"
    ],
    "modify": [
      "orchestrator/package.json"
    ],
    "forbidden": [
      "core/safety/*",
      ".env.production",
      "portal/*"
    ]
  },

  "technical_requirements": {
    "database_tables": [
      "wave_sessions",
      "wave_checkpoints",
      "wave_story_executions"
    ],
    "reuse_patterns": {
      "prisma_client": "Singleton pattern for Prisma client",
      "repository_pattern": "Each table gets a repository class"
    },
    "state_management": "Prisma Client with connection pooling"
  },

  "tdd": {
    "test_framework": "vitest",
    "test_files": [
      "orchestrator/src/db/__tests__/sessions.test.ts",
      "orchestrator/src/db/__tests__/checkpoints.test.ts"
    ],
    "coverage_target": 80,
    "test_categories": [
      {
        "name": "Session CRUD",
        "count": 5,
        "examples": [
          "should create session with valid data",
          "should read session by ID",
          "should update session status",
          "should list sessions by project",
          "should handle concurrent creates"
        ]
      },
      {
        "name": "Checkpoint CRUD",
        "count": 4,
        "examples": [
          "should create checkpoint for session",
          "should get latest checkpoint",
          "should list checkpoints by session",
          "should handle large state objects"
        ]
      },
      {
        "name": "Story Execution CRUD",
        "count": 3,
        "examples": [
          "should create story execution",
          "should update gate progress",
          "should track token usage"
        ]
      }
    ],
    "mocking_strategy": {
      "database": "Use test database with transactions"
    }
  },

  "safety": {
    "stop_conditions": [
      "Any modification to production database",
      "Dropping existing tables without backup",
      "Migration contains destructive operations"
    ],
    "escalation_triggers": [
      "Migration conflicts with existing schema",
      "Schema design questions",
      "Performance concerns with large datasets"
    ],
    "rollback_plan": "prisma migrate reset to drop all tables and reapply migrations"
  },

  "hazard_analysis": {
    "identified_hazards": [
      {
        "id": "HAZ-001",
        "description": "Data loss if migration drops tables",
        "severity": "critical",
        "likelihood": "remote",
        "mitigation": "Never use DROP in migrations, always use ALTER"
      },
      {
        "id": "HAZ-002",
        "description": "Connection pool exhaustion",
        "severity": "major",
        "likelihood": "occasional",
        "mitigation": "Use singleton Prisma client with connection limit"
      }
    ],
    "risk_level": "medium"
  },

  "dependencies": {
    "required_before": ["WAVE-P0-001"],
    "blocks": ["WAVE-P1-002", "WAVE-P1-003"]
  },

  "traceability": {
    "requirements": ["WAVE-ARCH-002", "STATE-PERSISTENCE-001"],
    "epic": "WAVE State Persistence",
    "related_stories": ["WAVE-P1-002"]
  },

  "gates_completed": [],
  "estimated_tests": 12,
  "estimated_tokens": 25000,

  "metadata": {
    "created_at": "2026-02-06T00:00:00Z",
    "created_by": "cto-analysis",
    "agent_assignment": "be-dev-1"
  },

  "notes": "Use Prisma's built-in connection pooling. Consider PgBouncer for production scale."
}
