{
  "$schema": "../../planning/schemas/story-schema-v4.2.json",
  "schema_version": "4.2",
  "story_id": "WAVE-P4-002",
  "title": "Implement Domain Scoper for Context Optimization",
  "type": "feature",
  "domain": "backend",
  "agent": "be-dev",
  "wave_number": 4,
  "priority": "P1",
  "story_points": 5,
  "status": "pending",
  "description": "Create a domain scoper that analyzes the codebase and determines which files are relevant for each domain. Uses static analysis, import graphs, and domain configuration to build a precise scope. Enables agents to load only what they need.",

  "objective": {
    "as_a": "WAVE Context Manager",
    "i_want": "precise domain scoping based on code analysis",
    "so_that": "agents load exactly the files they need, not entire directories"
  },

  "acceptance_criteria": [
    {
      "id": "AC-01",
      "description": "Domain scope computed from configuration",
      "ears_format": "WHEN domain scoper initialized THEN scope built from wave-config.json patterns",
      "test_approach": "Initialize scoper, verify scope matches config patterns",
      "status": "pending"
    },
    {
      "id": "AC-02",
      "description": "Import graph analyzed for dependencies",
      "ears_format": "WHEN file in scope has imports THEN imported files added to scope transitively",
      "test_approach": "Scope file with imports, verify dependencies included",
      "status": "pending"
    },
    {
      "id": "AC-03",
      "description": "Shared dependencies identified correctly",
      "ears_format": "WHEN file imported by multiple domains THEN marked as shared",
      "test_approach": "Create cross-domain import, verify shared marking",
      "status": "pending"
    },
    {
      "id": "AC-04",
      "description": "Scope caching for performance",
      "ears_format": "WHEN scope computed THEN cached until file changes detected",
      "test_approach": "Compute scope twice, verify second is from cache",
      "status": "pending"
    },
    {
      "id": "AC-05",
      "description": "Scope provides file relevance ranking",
      "ears_format": "WHEN scope queried THEN files returned with relevance score 0-1",
      "test_approach": "Query scope, verify scores present and ordered",
      "status": "pending"
    },
    {
      "id": "AC-06",
      "description": "Scope invalidated on file changes",
      "ears_format": "WHEN file modified THEN affected scope entries invalidated",
      "test_approach": "Modify file, verify scope recomputed",
      "status": "pending"
    }
  ],

  "files": {
    "create": [
      "orchestrator/src/rlm/scoper/domain-scoper.ts",
      "orchestrator/src/rlm/scoper/import-analyzer.ts",
      "orchestrator/src/rlm/scoper/scope-cache.ts",
      "orchestrator/src/rlm/scoper/relevance-scorer.ts",
      "orchestrator/src/rlm/scoper/types.ts",
      "orchestrator/src/rlm/scoper/__tests__/domain-scoper.test.ts",
      "orchestrator/src/rlm/scoper/__tests__/import-analyzer.test.ts"
    ],
    "modify": [
      "orchestrator/src/rlm/context-manager.ts"
    ],
    "forbidden": [
      "core/safety/*"
    ]
  },

  "technical_requirements": {
    "reuse_patterns": {
      "import_parsing": "Use TypeScript compiler API or babel for import analysis",
      "graph_traversal": "BFS for transitive dependencies",
      "caching": "LRU cache with file watcher invalidation"
    },
    "reuse_components": [
      "orchestrator/src/domains/domain-rules.ts"
    ]
  },

  "tdd": {
    "test_framework": "vitest",
    "test_files": [
      "orchestrator/src/rlm/scoper/__tests__/domain-scoper.test.ts",
      "orchestrator/src/rlm/scoper/__tests__/import-analyzer.test.ts"
    ],
    "coverage_target": 85,
    "test_categories": [
      {
        "name": "Scope Computation",
        "count": 4,
        "examples": [
          "should compute scope from config",
          "should include transitive imports",
          "should identify shared files",
          "should rank by relevance"
        ]
      },
      {
        "name": "Caching",
        "count": 3,
        "examples": [
          "should cache computed scopes",
          "should invalidate on file change",
          "should handle cache misses"
        ]
      },
      {
        "name": "Import Analysis",
        "count": 4,
        "examples": [
          "should parse TypeScript imports",
          "should handle circular imports",
          "should support path aliases",
          "should handle dynamic imports"
        ]
      }
    ],
    "mocking_strategy": {
      "filesystem": "Real filesystem with test fixtures",
      "typescript": "Real TypeScript compiler API"
    }
  },

  "safety": {
    "stop_conditions": [
      "Import analysis causes infinite loop",
      "Scope computation exceeds 30 seconds",
      "Memory usage exceeds 1GB"
    ],
    "escalation_triggers": [
      "Circular import handling fails",
      "Scope misses critical files"
    ],
    "rollback_plan": "Use simple glob-based scoping from config"
  },

  "dependencies": {
    "required_before": ["WAVE-P4-001"],
    "blocks": ["WAVE-P4-003"]
  },

  "traceability": {
    "requirements": ["RLM-002", "CONTEXT-OPT-001"],
    "epic": "WAVE RLM Integration",
    "related_stories": ["WAVE-P4-001", "WAVE-P4-003"]
  },

  "gates_completed": [],
  "estimated_tests": 11,
  "estimated_tokens": 30000,

  "metadata": {
    "created_at": "2026-02-07T00:00:00Z",
    "created_by": "cto-analysis",
    "agent_assignment": "be-dev-1"
  },

  "notes": "Domain scoping is key to RLM efficiency. Use TypeScript compiler API for accurate import analysis. Consider using ts-morph for easier AST manipulation."
}
