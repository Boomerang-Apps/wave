{
  "$schema": "../../planning/schemas/story-schema-v4.2.json",
  "schema_version": "4.2",
  "story_id": "WAVE-P4-003",
  "title": "Implement Subagent Spawner for Complex Tasks",
  "type": "feature",
  "domain": "backend",
  "agent": "be-dev",
  "wave_number": 4,
  "priority": "P1",
  "story_points": 8,
  "status": "pending",
  "description": "Create a subagent spawner that allows agents to delegate subtasks to child agents. Each subagent has limited scope and shorter context, enabling efficient handling of complex stories without context overflow. Based on RLM subagent pattern.",

  "objective": {
    "as_a": "WAVE Agent",
    "i_want": "to spawn subagents for complex subtasks",
    "so_that": "I can handle complex stories by delegating parts to focused subagents"
  },

  "acceptance_criteria": [
    {
      "id": "AC-01",
      "description": "Parent agent can spawn subagent for subtask",
      "ears_format": "WHEN agent encounters complex subtask THEN it can spawn a subagent with limited scope",
      "test_approach": "Parent requests subagent, verify subagent created",
      "status": "pending"
    },
    {
      "id": "AC-02",
      "description": "Subagent has isolated context",
      "ears_format": "WHEN subagent spawned THEN it has fresh context with only relevant files",
      "test_approach": "Spawn subagent, verify context is minimal",
      "status": "pending"
    },
    {
      "id": "AC-03",
      "description": "Subagent results returned to parent",
      "ears_format": "WHEN subagent completes THEN results passed back to parent agent",
      "test_approach": "Subagent completes task, verify parent receives results",
      "status": "pending"
    },
    {
      "id": "AC-04",
      "description": "Subagent errors bubble up properly",
      "ears_format": "WHEN subagent fails THEN error reported to parent with context",
      "test_approach": "Force subagent failure, verify parent receives error",
      "status": "pending"
    },
    {
      "id": "AC-05",
      "description": "Subagent depth limited",
      "ears_format": "WHEN subagent tries to spawn another subagent THEN depth checked (max 3 levels)",
      "threshold": "max depth: 3",
      "test_approach": "Attempt 4-level nesting, verify rejection",
      "status": "pending"
    },
    {
      "id": "AC-06",
      "description": "Subagent uses appropriate model tier",
      "ears_format": "WHEN subagent spawned THEN model tier matches task complexity (haiku for simple)",
      "test_approach": "Spawn for simple task, verify haiku model used",
      "status": "pending"
    },
    {
      "id": "AC-07",
      "description": "Subagent resource usage tracked",
      "ears_format": "WHEN subagent completes THEN token usage attributed to parent story",
      "test_approach": "Complete subagent task, verify tokens tracked on parent",
      "status": "pending"
    }
  ],

  "files": {
    "create": [
      "orchestrator/src/rlm/subagent/spawner.ts",
      "orchestrator/src/rlm/subagent/subagent.ts",
      "orchestrator/src/rlm/subagent/result-collector.ts",
      "orchestrator/src/rlm/subagent/types.ts",
      "orchestrator/src/rlm/subagent/__tests__/spawner.test.ts",
      "orchestrator/src/rlm/subagent/__tests__/subagent.test.ts",
      "orchestrator/src/rlm/subagent/__tests__/integration.test.ts"
    ],
    "modify": [
      "orchestrator/src/agents/base-agent.ts",
      "orchestrator/src/rlm/context-manager.ts"
    ],
    "forbidden": [
      "core/safety/*"
    ]
  },

  "technical_requirements": {
    "reuse_patterns": {
      "fork_join": "Parent spawns subagents, waits for all to complete",
      "model_tiering": "Opus for complex, Sonnet for medium, Haiku for simple"
    },
    "reuse_components": [
      "orchestrator/src/rlm/context-manager.ts",
      "orchestrator/src/rlm/scoper/domain-scoper.ts"
    ],
    "state_management": "Subagent state tracked in parent session"
  },

  "tdd": {
    "test_framework": "vitest",
    "test_files": [
      "orchestrator/src/rlm/subagent/__tests__/spawner.test.ts",
      "orchestrator/src/rlm/subagent/__tests__/subagent.test.ts",
      "orchestrator/src/rlm/subagent/__tests__/integration.test.ts"
    ],
    "coverage_target": 85,
    "test_categories": [
      {
        "name": "Subagent Spawning",
        "count": 4,
        "examples": [
          "should spawn subagent for subtask",
          "should create isolated context",
          "should enforce depth limit",
          "should select appropriate model tier"
        ]
      },
      {
        "name": "Result Handling",
        "count": 4,
        "examples": [
          "should return results to parent",
          "should bubble up errors",
          "should handle subagent timeout",
          "should collect from multiple subagents"
        ]
      },
      {
        "name": "Resource Tracking",
        "count": 3,
        "examples": [
          "should track subagent tokens",
          "should attribute to parent story",
          "should enforce budget limits"
        ]
      }
    ],
    "mocking_strategy": {
      "llm": "Mock LLM calls for testing",
      "agents": "Lightweight test subagents"
    }
  },

  "safety": {
    "stop_conditions": [
      "Subagent depth exceeds limit",
      "Subagent token usage exceeds budget",
      "Subagent deadlock detected"
    ],
    "escalation_triggers": [
      "Subagent fails repeatedly",
      "Subagent takes >10 minutes",
      "Resource usage anomaly"
    ],
    "rollback_plan": "Kill subagent, return error to parent, parent continues without delegation"
  },

  "dependencies": {
    "required_before": ["WAVE-P4-002"],
    "blocks": ["WAVE-P5-001"]
  },

  "traceability": {
    "requirements": ["RLM-003", "SUBAGENT-001"],
    "epic": "WAVE RLM Integration",
    "related_stories": ["WAVE-P4-001", "WAVE-P4-002"]
  },

  "gates_completed": [],
  "estimated_tests": 11,
  "estimated_tokens": 35000,

  "metadata": {
    "created_at": "2026-02-07T00:00:00Z",
    "created_by": "cto-analysis",
    "agent_assignment": "be-dev-1"
  },

  "notes": "Subagent pattern is key to handling complex tasks efficiently. Each subagent should be short-lived with minimal context. Use Haiku for simple tasks to reduce costs."
}
