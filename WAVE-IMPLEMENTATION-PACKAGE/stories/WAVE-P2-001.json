{
  "$schema": "../../planning/schemas/story-schema-v4.2.json",
  "schema_version": "4.2",
  "story_id": "WAVE-P2-001",
  "title": "Implement Redis Pub/Sub Infrastructure",
  "type": "infrastructure",
  "domain": "backend",
  "agent": "be-dev",
  "wave_number": 2,
  "priority": "P0",
  "story_points": 8,
  "status": "pending",
  "description": "Create Redis Streams-based pub/sub infrastructure for WAVE inter-agent communication. This replaces the current polling-based signal detection (10s latency) with event-driven messaging (<100ms latency). 100x improvement.",

  "objective": {
    "as_a": "WAVE Orchestrator",
    "i_want": "event-driven communication between agents",
    "so_that": "signal latency is reduced from 10 seconds to under 100 milliseconds"
  },

  "acceptance_criteria": [
    {
      "id": "AC-01",
      "description": "Redis client connects and supports pub/sub operations",
      "ears_format": "WHEN message published to channel THEN subscribers receive within 100ms",
      "threshold": "latency: <100ms",
      "test_approach": "Publish message, measure time to receive in subscriber",
      "status": "pending"
    },
    {
      "id": "AC-02",
      "description": "Consumer groups enable load balancing",
      "ears_format": "WHEN multiple consumers in group THEN messages are distributed evenly",
      "test_approach": "Start 3 consumers, publish 9 messages, verify ~3 per consumer",
      "status": "pending"
    },
    {
      "id": "AC-03",
      "description": "Messages persist until acknowledged",
      "ears_format": "WHEN consumer crashes before ack THEN message is redelivered to another consumer",
      "test_approach": "Consume without ack, kill consumer, verify redelivery",
      "status": "pending"
    },
    {
      "id": "AC-04",
      "description": "Channels are properly namespaced by project",
      "ears_format": "WHEN message sent to wave:signals:projectA THEN projectB does not receive",
      "test_approach": "Subscribe to two projects, publish to one, verify isolation",
      "status": "pending"
    },
    {
      "id": "AC-05",
      "description": "Connection recovery after Redis restart",
      "ears_format": "WHEN Redis restarts THEN client reconnects automatically within 5s",
      "threshold": "reconnect time: <5s",
      "test_approach": "Restart Redis container, measure reconnection time",
      "status": "pending"
    }
  ],

  "files": {
    "create": [
      "orchestrator/src/pubsub/redis-client.ts",
      "orchestrator/src/pubsub/publisher.ts",
      "orchestrator/src/pubsub/subscriber.ts",
      "orchestrator/src/pubsub/channels.ts",
      "orchestrator/src/pubsub/types.ts",
      "orchestrator/src/pubsub/__tests__/redis-client.test.ts",
      "orchestrator/src/pubsub/__tests__/pubsub-integration.test.ts"
    ],
    "modify": [
      "orchestrator/package.json"
    ],
    "forbidden": [
      "core/scripts/merge-watcher*.sh"
    ]
  },

  "technical_requirements": {
    "reuse_patterns": {
      "redis_client": "ioredis with Streams API",
      "consumer_groups": "XREADGROUP for load balancing",
      "reconnection": "Exponential backoff with jitter"
    },
    "state_management": "Redis Streams with consumer groups"
  },

  "tdd": {
    "test_framework": "vitest",
    "test_files": [
      "orchestrator/src/pubsub/__tests__/redis-client.test.ts",
      "orchestrator/src/pubsub/__tests__/pubsub-integration.test.ts"
    ],
    "coverage_target": 85,
    "test_categories": [
      {
        "name": "Publishing",
        "count": 4,
        "examples": [
          "should publish message to stream",
          "should batch publish multiple messages",
          "should handle connection failure gracefully",
          "should retry failed publishes"
        ]
      },
      {
        "name": "Subscribing",
        "count": 5,
        "examples": [
          "should receive published messages",
          "should distribute across consumer group",
          "should acknowledge processed messages",
          "should redeliver unacked messages",
          "should handle consumer failures"
        ]
      },
      {
        "name": "Performance",
        "count": 3,
        "examples": [
          "should deliver messages in <100ms",
          "should handle 100 messages/second",
          "should maintain performance under load"
        ]
      },
      {
        "name": "Recovery",
        "count": 2,
        "examples": [
          "should reconnect after Redis restart",
          "should resume from last position"
        ]
      }
    ],
    "mocking_strategy": {
      "redis": "Real Redis in test container"
    }
  },

  "safety": {
    "stop_conditions": [
      "Redis connection permanently lost (>5 retries)",
      "Message queue overflow (>10000 pending)",
      "Memory exhaustion"
    ],
    "escalation_triggers": [
      "Latency exceeds 500ms",
      "Consumer group issues",
      "Message loss detected"
    ],
    "rollback_plan": "Fall back to file-based polling temporarily, flush Redis streams"
  },

  "hazard_analysis": {
    "identified_hazards": [
      {
        "id": "HAZ-001",
        "description": "Message loss during Redis failure",
        "severity": "critical",
        "likelihood": "remote",
        "mitigation": "Enable Redis persistence (AOF), verify delivery"
      },
      {
        "id": "HAZ-002",
        "description": "Consumer stuck in processing loop",
        "severity": "major",
        "likelihood": "occasional",
        "mitigation": "Implement processing timeout, dead letter queue"
      }
    ],
    "risk_level": "medium"
  },

  "dependencies": {
    "required_before": ["WAVE-P1-002"],
    "blocks": ["WAVE-P2-002"]
  },

  "traceability": {
    "requirements": ["EVENT-DRIVEN-001", "LATENCY-001"],
    "epic": "WAVE Event-Driven Communication",
    "related_stories": ["WAVE-P2-002"]
  },

  "gates_completed": [],
  "estimated_tests": 14,
  "estimated_tokens": 30000,

  "metadata": {
    "created_at": "2026-02-06T00:00:00Z",
    "created_by": "cto-analysis",
    "agent_assignment": "be-dev-1"
  },

  "notes": "Use Redis Streams (XADD/XREADGROUP) not Pub/Sub (PUBLISH/SUBSCRIBE) for durability. Streams persist and support consumer groups."
}
